<!DOCTYPE html>
<html lang="en" data-bs-theme="dark"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>SonoGlyph</title>
  <link href="./assets/css/bootstrap.min.css" rel="stylesheet">
  <style>
    :root{ --gg-bg:#0c1020; --gg-card:#121735; --gg-ink:#eef1ff; --gg-ink-dim:#b9c6ef; --gg-border:#2b3868; }
    html,body{height:100%}
    body::before{ content:""; position:fixed; inset:0; z-index:-1; pointer-events:none; background:
        radial-gradient(1200px 600px at 12% -10%, #273056 0%, rgba(23,26,38,0) 60%),
        radial-gradient(1200px 600px at 88% 110%, #1f2648 0%, rgba(23,26,38,0) 55%);
      background-repeat:no-repeat; background-attachment:fixed; }
    body{ background:var(--gg-bg); color:var(--gg-ink); -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale; }
    .gg-card{ background:linear-gradient(180deg,#151c3b,#13183a); border:1px solid var(--gg-border); border-radius:14px; box-shadow:0 10px 30px rgba(0,0,0,.35); }
    .gg-border{ border-color:var(--gg-border)!important; }
    .gg-badge{ background:#1a2147; color:#a6b6f0; border:1px solid var(--gg-border); }
    .text-dim{ color:var(--gg-ink-dim) }
    .spec-wrap{ position:relative; overflow:auto; border:1px solid var(--gg-border); border-radius:12px; background:#0f1432; }
    canvas{ image-rendering:pixelated; }
    .form-text { color: var(--gg-ink-dim); }
  </style>

<script>
window.makeSafeObjectURL = function(blob){
  try { return URL.createObjectURL(blob); }
  catch(e){
    // Fallback to data URL
    try {
      const reader = new FileReader();
      return new Promise((resolve, reject)=>{
        reader.onerror = reject;
        reader.onload = ()=>resolve(reader.result);
        reader.readAsDataURL(blob);
      });
    } catch(e2){ return null; }
  }
};
</script>


<script>
function setSrcFromMaybePromise(el, maybeUrl){
  try{
    if(maybeUrl && typeof maybeUrl.then === 'function'){
      maybeUrl.then(u => { if(u) el.src = u; }).catch(()=>{});
    }else if(maybeUrl){
      el.src = maybeUrl;
    }
  }catch(e){}
}
</script>

</head>
<body>
  <nav class="navbar navbar-expand-md bg-body-tertiary sticky-top border-bottom border-dark-subtle">
    <div class="container-lg">
      <a class="navbar-brand fw-bold" href="https://nqrlabs.github.io/SonoGlyph/#">SonoGlyph</a>
      <span class="navbar-text small text-secondary ms-1">Spectrogram-Driven Steganography</span>
    </div>
  </nav>

  <main class="container-lg my-4">
    <section class="gg-card p-3 mb-3">
      <div class="d-flex align-items-center gap-2 pb-2 border-bottom gg-border">
        <span class="badge rounded-pill gg-badge">Open files &amp; settings</span>
        <div class="ms-auto small text-dim" id="status">Done. Preview or re-embed if needed.</div>
      </div>
      <div class="row g-3 pt-3 align-items-end">
        <div class="col-12 col-md-5">
          <label class="form-label small text-secondary" for="fileAudio">Audio file</label>
          <input type="file" id="fileAudio" class="form-control" accept="audio/*">
        </div>
        <div class="col-12 col-md-5">
          <label class="form-label small text-secondary" for="fileImage">Image to embed</label>
          <input type="file" id="fileImage" class="form-control" accept="image/*">
          <div class="row g-2 mt-2">
            <div class="col-6">
              <div class="form-check">
                <input class="form-check-input" type="checkbox" id="flipVertical" checked="">
                <label class="form-check-label small" for="flipVertical">Top of image â†’ high frequencies</label>
              </div>
            </div>
            <div class="col-6">
              <div class="form-check">
                <input class="form-check-input" type="checkbox" id="invertImage">
                <label class="form-check-label small" for="invertImage">Invert image (white â†” black)</label>
              </div>
            </div>
          </div>
        </div>
        <div class="col-6 col-md-2">
          <label class="form-label small text-secondary" for="fftSize">FFT size</label>
          <select id="fftSize" class="form-select"><option selected="">1024</option><option>2048</option><option>4096</option><option>8192</option></select>
        </div>
        <div class="col-6 col-md-2">
          <label class="form-label small text-secondary" for="hopPct">Hop (%)</label>
          <input type="number" id="hopPct" class="form-control" value="25" min="5" max="90">
          <div class="form-text">Lower = smoother spectrogram</div>
        </div>
        <div class="col-6 col-md-2">
          <label class="form-label small text-secondary" for="minHz">Embed min Hz</label>
          <input type="number" id="minHz" class="form-control" value="8000" min="0">
        </div>
        <div class="col-6 col-md-2">
          <label class="form-label small text-secondary" for="maxHz">Embed max Hz</label>
          <input type="number" id="maxHz" class="form-control" value="18000">
        </div>
        <div class="col-6 col-md-2">
          <label class="form-label small text-secondary" for="strength">Mix strength</label>
          <input type="range" id="strength" class="form-range" min="0" max="200" value="35">
          <div class="form-text">Higher = more visible, more audible</div>
        </div>
        <div class="col-6 col-md-2">
          <label class="form-label small text-secondary" for="glIters">GL iters</label>
          <input type="number" id="glIters" class="form-control" value="6" min="0" max="12">
          <div class="form-text">Griffinâ€“Lim iterations</div>
        </div>
        <div class="col-12 col-md-4 d-grid d-md-flex gap-2">
          <button id="btnPreview" class="btn btn-outline-light">Preview spectrogram</button>
          <button id="btnEmbed" class="btn btn-primary">Embed image &amp; download WAV</button>
        </div>
      </div>
      <div class="row g-2 mt-2 small text-dim">
      </div>
    </section>

    <section class="gg-card p-3 mb-3">
      <div class="d-flex align-items-center gap-2 pb-2 border-bottom gg-border">
        <span class="badge rounded-pill gg-badge">Players</span>
      </div>
      <div class="row g-3 pt-3">
        <div class="col-12 col-lg-6">
          <div class="small text-dim mb-1">Original</div>
          <audio id="playerOrig" controls="" class="w-100"></audio>
        </div>
        <div class="col-12 col-lg-6">
          <div class="small text-dim mb-1">With embedded image</div>
          <audio id="playerOut" controls="" class="w-100"></audio>
        </div>
      </div>
    </section>

    <section class="gg-card p-3">
      <div class="d-flex align-items-center gap-2 pb-2 border-bottom gg-border">
        <span class="badge rounded-pill gg-badge">Spectrograms</span>
        <div class="ms-auto small text-dim" id="cursor">Ready</div>
      </div>
      <div class="row g-3 pt-3">
        <div class="col-12 col-xl-6">
          <div class="small text-dim mb-2">Original audio</div>
          <div class="spec-wrap"><canvas id="specA" width="471" height="400"></canvas></div>
        </div>
        <div class="col-12 col-xl-6">
          <div class="small text-dim mb-2">After embedding</div>
          <div class="spec-wrap"><canvas id="specB" width="471" height="400"></canvas></div>
        </div>
      </div>
    </section>
  </main>

<script>
'use strict';

/* ===== utilities ===== */
const hann = N => { const w=new Float32Array(N); for(let n=0;n<N;n++) w[n]=0.5*(1-Math.cos(2*Math.PI*n/(N-1))); return w; };

/* radix-2 FFT / IFFT */
function FFT(N,re,im){
  let i=0,j=0;
  for(i=0;i<N;i++){
    if(j>i){ const tr=re[i]; re[i]=re[j]; re[j]=tr; const ti=im[i]; im[i]=im[j]; im[j]=ti; }
    let m=N>>1; while(m>=1 && j>=m){ j-=m; m>>=1; } j+=m;
  }
  for(let len=2; len<=N; len<<=1){
    const ang=-2*Math.PI/len, wlr=Math.cos(ang), wli=Math.sin(ang);
    for(let i2=0;i2<N;i2+=len){
      let wr=1, wi=0;
      for(let k=0;k<len/2;k++){
        const ur=re[i2+k], ui=im[i2+k];
        const vr=re[i2+k+len/2]*wr - im[i2+k+len/2]*wi;
        const vi=re[i2+k+len/2]*wi + im[i2+k+len/2]*wr;
        re[i2+k]=ur+vr; im[i2+k]=ui+vi;
        re[i2+k+len/2]=ur-vr; im[i2+k+len/2]=ui-vi;
        const nwr=wr*wlr - wi*wli; wi=wr*wli + wi*wlr; wr=nwr;
      }
    }
  }
}
function IFFT(N,re,im){ for(let i=0;i<N;i++){ im[i]=-im[i]; } FFT(N,re,im); for(let i=0;i<N;i++){ re[i]=re[i]/N; im[i]=-im[i]/N; } }

/* palette for preview spectrogram */
function makeLUT(){
  const lut=new Uint8ClampedArray(256*4);
  for(let i=0;i<256;i++){
    const t=i/255; let r,g,b;
    if(t<0.25){ const u=t/0.25; r=40*u; g=20*u; b=60+120*u; }
    else if(t<0.5){ const u=(t-0.25)/0.25; r=40+160*u; g=20*(1-u); b=180-40*u; }
    else if(t<0.75){ const u=(t-0.5)/0.25; r=200+40*u; g=20+150*u; b=140*(1-u); }
    else { const u=(t-0.75)/0.25; r=240+15*u; g=170+85*u; b=0+40*u; }
    lut[i*4]=r|0; lut[i*4+1]=g|0; lut[i*4+2]=b|0; lut[i*4+3]=255;
  }
  return lut;
}
const LUT=makeLUT();

/* simple WAV encoder */
function encodeWav(float32,sampleRate){
  const len=float32.length; const buffer=new ArrayBuffer(44+len*2); const view=new DataView(buffer);
  function setStr(o,s){ for(let i=0;i<s.length;i++){ view.setUint8(o+i,s.charCodeAt(i)); } }
  function clamp(v){ return v<-1?-1:(v>1?1:v); }
  setStr(0,'RIFF'); view.setUint32(4,36+len*2,true); setStr(8,'WAVE'); setStr(12,'fmt '); view.setUint32(16,16,true); setStr(20,'\x01\x00'); setStr(22,'\x01\x00');
  view.setUint32(24,sampleRate,true); view.setUint32(28,sampleRate*2,true); setStr(32,'\x02\x00'); setStr(34,'\x10\x00'); setStr(36,'data'); view.setUint32(40,len*2,true);
  let off=44; for(let i=0;i<len;i++,off+=2){ view.setInt16(off,(clamp(float32[i])*0x7fff)|0,true); }
  return new Blob([view],{type:'audio/wav'});
}

/* ===== state ===== */
let audioCtx=null, srcPCM=null, sampleRate=48000, duration=0, outPCM=null;
const els={ fileAudio:document.getElementById('fileAudio'), fileImage:document.getElementById('fileImage'), status:document.getElementById('status'),
  playerOrig:document.getElementById('playerOrig'), playerOut:document.getElementById('playerOut'), specA:document.getElementById('specA'), specB:document.getElementById('specB'),
  btnPreview:document.getElementById('btnPreview'), btnEmbed:document.getElementById('btnEmbed'), fftSize:document.getElementById('fftSize'), hopPct:document.getElementById('hopPct'),
  minHz:document.getElementById('minHz'), maxHz:document.getElementById('maxHz'), strength:document.getElementById('strength'), flipVertical:document.getElementById('flipVertical'),
  invertImage:document.getElementById('invertImage'), glIters:document.getElementById('glIters') };

function refreshButtons(){
  const hasAudio = !!(els.fileAudio.files && els.fileAudio.files.length);
  const hasImage = !!(els.fileImage.files && els.fileImage.files.length);
  els.btnPreview.disabled = !hasAudio;
  els.btnEmbed.disabled = !(hasAudio && hasImage);
}



/* ===== loaders ===== */
async function decodeAudio(file){
  if(!audioCtx){ audioCtx=new (window.AudioContext||window.webkitAudioContext)(); }
  const arr=await file.arrayBuffer(); const dec=await audioCtx.decodeAudioData(arr);
  sampleRate=dec.sampleRate; duration=dec.duration;
  const L=dec.getChannelData(0); if(dec.numberOfChannels>1){ const R=dec.getChannelData(1); const n=Math.min(L.length,R.length); const m=new Float32Array(n); for(let i=0;i<n;i++){ m[i]=(L[i]+R[i])*0.5; } srcPCM=m; } else { srcPCM=new Float32Array(L); }
  els.status.textContent='Loaded '+file.name+' Â· '+duration.toFixed(2)+'s @ '+(sampleRate|0)+'Hz';
  (() => { const wav = encodeWav(srcPCM, sampleRate); const u = window.makeSafeObjectURL(wav); if(u && u.then){ u.then(url=>els.playerOrig.src=url); } else if(u) { els.playerOrig.src = u; } })();
  els.btnPreview.disabled=false; els.btnEmbed.disabled=!(els.fileImage.files.length);
}
els.fileAudio.addEventListener('change', async ()=>{ const f=els.fileAudio.files&&els.fileAudio.files[0]; if(f) await decodeAudio(f); refreshButtons(); });
els.fileImage.addEventListener('change', ()=>{ refreshButtons(); 
refreshButtons();
});

/* ===== preview spectrogram ===== */
async function renderSpec(canvas, pcm, sr, N, hopFrac, minHz, maxHz){
  if(!pcm) return; const hop=Math.max(1,Math.round(N*hopFrac));
  const frames=1+Math.floor((pcm.length-N)/hop); const bins=N/2|0; const ny=sr/2;
  if(!maxHz) maxHz=ny;
  const minBin=Math.max(0,Math.floor(minHz/ny*(bins-1))); const maxBin=Math.min(bins-1,Math.ceil(maxHz/ny*(bins-1)));
  const used=maxBin-minBin+1; const win=hann(N); const re=new Float32Array(N), im=new Float32Array(N);
  const off=document.createElement('canvas'); off.width=frames; off.height=used; const octx=off.getContext('2d'); const img=octx.createImageData(frames,used); const data=img.data;
  let peak=1e-9;
  for(let f=0,p=0; f<frames; f++,p+=hop){ for(let i=0;i<N;i++){ re[i]=(pcm[p+i]||0)*win[i]; im[i]=0; } FFT(N,re,im); for(let k=minBin;k<=maxBin;k++){ const m=Math.hypot(re[k],im[k]); if(m>peak) peak=m; } }
  for(let f=0,p=0; f<frames; f++,p+=hop){
    for(let i=0;i<N;i++){ re[i]=(pcm[p+i]||0)*win[i]; im[i]=0; } FFT(N,re,im);
    for(let k=minBin;k<=maxBin;k++){
      const mag=Math.hypot(re[k],im[k])/(peak||1); const v=(Math.max(0,Math.min(1, Math.log10(1+9*mag))))*255|0;
      const y=maxBin-k; const di=(y*frames+f)*4;
      data[di]=LUT[v*4]; data[di+1]=LUT[v*4+1]; data[di+2]=LUT[v*4+2]; data[di+3]=255;
    }
  }
  octx.putImageData(img,0,0); canvas.width=Math.min(frames,1800); canvas.height=400;
  const ctx=canvas.getContext('2d'); ctx.fillStyle='#0f1432'; ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.imageSmoothingEnabled=false; ctx.drawImage(off,0,0,off.width,off.height, 0,0,canvas.width,canvas.height);
}

/* ===== STFT helpers ===== */
function stft(pcm, N, hop){
  const win=hann(N); const frames=1+Math.floor((pcm.length-N)/hop); const re=new Float32Array(N), im=new Float32Array(N);
  const bins=N/2|0;
  const Ms=new Array(frames), Ph=new Array(frames);
  for(let f=0,p=0; f<frames; f++,p+=hop){
    for(let n=0;n<N;n++){ re[n]=(pcm[p+n]||0)*win[n]; im[n]=0; }
    FFT(N,re,im);
    const m=new Float32Array(bins+1), ph=new Float32Array(bins+1);
    for(let k=0;k<=bins;k++){ const rr=re[k], ii=im[k]; m[k]=Math.hypot(rr,ii); ph[k]=Math.atan2(ii,rr); }
    Ms[f]=m; Ph[f]=ph;
  }
  return {Ms, Ph, frames, bins};
}
function istft(Ms, Ph, N, hop, length){
  const win=hann(N); const bins=N/2|0;
  const out=new Float32Array(length); const re=new Float32Array(N), im=new Float32Array(N);
  for(let f=0,p=0; f<Ms.length; f++,p+=hop){
    const m=Ms[f], ph=Ph[f];
    for(let k=0;k<=bins;k++){ re[k]=m[k]*Math.cos(ph[k]); im[k]=(k===0||k===bins)?0:(m[k]*Math.sin(ph[k])); }
    for(let k=bins+1;k<N;k++){ const rk=N-k; re[k]=re[rk]; im[k]=-im[rk]; }
    IFFT(N,re,im);
    for(let n=0;n<N && (p+n)<out.length; n++) out[p+n]+=re[n]*win[n];
  }
  // soft normalize
  let peak=0; for(let i=0;i<out.length;i++){ const a=Math.abs(out[i]); if(a>peak) peak=a; }
  if(peak>0.99){ const g=0.99/peak; for(let i=0;i<out.length;i++) out[i]*=g; }
  return out;
}
function griffinLim(targetMag, N, hop, iters, sampleLength){
  const frames=targetMag.length; const bins=targetMag[0].length-1;
  let Ph=new Array(frames);
  for(let f=0; f<frames; f++){ const ph=new Float32Array(bins+1); for(let k=0;k<=bins;k++){ ph[k]=Math.random()*2*Math.PI - Math.PI; if(k===0||k===bins) ph[k]=0; } Ph[f]=ph; }
  let Ms=targetMag.map(m=>Float32Array.from(m));
  for(let t=0;t<iters;t++){
    const y=istft(Ms, Ph, N, hop, sampleLength);
    const ana=stft(y, N, hop); const PhNew=ana.Ph;
    Ph=PhNew; Ms=targetMag.map((m)=>Float32Array.from(m));
  }
  return istft(Ms, Ph, N, hop, sampleLength);
}

/* ===== FIR bandpass (windowed-sinc, linear-phase) ===== */
function makeBandpassFIR(sampleRate, f1, f2, taps){
  const M=taps-1; const h=new Float32Array(taps);
  const fc1=f1/sampleRate, fc2=f2/sampleRate;
  const pi=Math.PI;
  for(let n=0;n<taps;n++){
    const m=n - M/2;
    const sinc = (x)=> (x===0?1:Math.sin(pi*x)/(pi*x));
    const lp2 = 2*fc2*sinc(2*fc2*m);
    const lp1 = 2*fc1*sinc(2*fc1*m);
    const bp = lp2 - lp1;
    // Hamming window
    const w = 0.54 - 0.46*Math.cos(2*pi*n/M);
    h[n]=bp*w;
  }
  // normalize to unity gain in passband approximately
  let sum=0; for(let i=0;i<taps;i++) sum+=h[i];
  for(let i=0;i<taps;i++) h[i]/=sum||1;
  return h;
}
function convolveFIR(x, h){
  const y=new Float32Array(x.length);
  const M=h.length;
  for(let n=0;n<y.length;n++){
    let acc=0;
    for(let k=0;k<M;k++){
      const i=n-k;
      if(i>=0) acc+=x[i]*h[k];
    }
    y[n]=acc;
  }
  return y;
}

/* ===== Build watermark from image spectrogram ===== */
async function buildWatermarkFromImage(N, hop, frames, bins, minBin, maxBin){
  const imgFile=els.fileImage.files[0];
  const flip=els.flipVertical.checked;
  const invert=els.invertImage.checked;
  const img=await createImageBitmap(imgFile);
  const used=maxBin-minBin+1;

  const c=document.createElement('canvas'); c.width=frames; c.height=used; const cx=c.getContext('2d');
  const scaleW=frames, scaleH=Math.round(img.height*(frames/img.width));
  cx.clearRect(0,0,frames,used);
  const yOffset=Math.max(0,(used-scaleH)/2);
  cx.drawImage(img,0,0,img.width,img.height, 0, yOffset, scaleW, Math.min(used,scaleH));
  const d=cx.getImageData(0,0,frames,used).data;

  let totalLum=0;
  const targetMag=new Array(frames);
  for(let f=0; f<frames; f++){
    const row=new Float32Array(bins+1);
    for(let y=0; y<used; y++){
      const srcY = flip ? (used-1 - y) : y;
      const i=(srcY*frames + f)*4; const r=d[i], g=d[i+1], b=d[i+2];
      let lum=(0.299*r + 0.587*g + 0.114*b)/255; // 0..1
      if(invert) lum = 1 - lum;
      totalLum += lum;
      const k=minBin + y;
      // base was causing residual watermark on black images; set base=0.
      row[k]= lum * 0.30;
    }
    targetMag[f]=row;
  }
  return {targetMag, totalLum};
}

/* ===== RMS utility ===== */
function rms(x){ let s=0; for(let i=0;i<x.length;i++){ const v=x[i]; s+=v*v; } return Math.sqrt(s/x.length); }

/* ===== Main embed ===== */
async function embedAndRender(){
  if(!srcPCM || !els.fileImage.files[0]) return;

  const N=Number(els.fftSize.value)|0;
  const hop=Math.max(1,Math.round(N*(Number(els.hopPct.value)/100)));
  const frames=1+Math.floor((srcPCM.length-N)/hop);
  const bins=N/2|0; const ny=sampleRate/2;
  const minHz = (els.minHz.value === "" ? 8000 : Math.max(0, Number(els.minHz.value)));
  const maxHz = (els.maxHz.value === "" ? 18000 : Math.max(0, Number(els.maxHz.value)));
  const minBin=Math.max(0,Math.floor(minHz/ny*(bins))), maxBin=Math.min(bins,Math.ceil(maxHz/ny*(bins)));

  els.status.textContent='Building watermarkâ€¦';
  const build=await buildWatermarkFromImage(N, hop, frames, bins, minBin, maxBin);

  // If the image is pure black (or nearly), do NOT embed.
  

if (build.totalLum < 1e-6) {
  els.status.textContent = 'Image is all black â€“ no changes applied.';
  outPCM = new Float32Array(srcPCM);
  const wav = encodeWav(outPCM, sampleRate);
  let uSafe = null;
  try{
    if(window.makeSafeObjectURL){ uSafe = window.makeSafeObjectURL(wav); }
    else { uSafe = URL.createObjectURL(wav); }
  }catch(e){ uSafe = null; }
  const doDownload = (url)=>{
    try{ els.playerOut.src = url; }catch(e){}
    const a = document.createElement('a');
    a.href = url;
    a.download = 'spectroghost_no_change.wav';
    a.click();
  };
  if(uSafe && typeof uSafe.then === 'function'){ uSafe.then(doDownload).catch(()=>{}); }
  else if(uSafe){ doDownload(uSafe); }
  await renderSpec(els.specB, outPCM, sampleRate, N, hop/N, 0, sampleRate/2);
  return;
}



  const targetMag = build.targetMag;
  const strengthPct = Number(els.strength.value);
  const strength = Math.max(0, Math.min(2, strengthPct/100));
  const iters = Math.max(0, Math.min(12, Number(els.glIters.value)|0));

  els.status.textContent='Running Griffinâ€“Limâ€¦';
  let wm = griffinLim(targetMag, N, hop, iters, srcPCM.length);

  // Band-limit watermark firmly in STFT domain
  const ST=stft(wm, N, hop); const Ms=ST.Ms, Ph=ST.Ph;
  for(let f=0; f<frames; f++){ const m=Ms[f]; for(let k=0;k<=bins;k++){ if(k<minBin || k>maxBin) m[k]=0; } }
  let wmBand = istft(Ms, Ph, N, hop, srcPCM.length);

  // Extra safety: linear-phase time-domain FIR bandpass to kill any leakage
  const taps = 513; // linear-phase; ~10ms at 48kHz
  const h = makeBandpassFIR(sampleRate, minHz, maxHz, taps);
  wmBand = convolveFIR(wmBand, h);

  // Scale watermark RMS relative to source, then mix
  const srcR = rms(srcPCM);
  let wmR = rms(wmBand);
  const targetR = srcR * strength;
const gain = wmR>1e-12 ? (targetR / wmR) : 0;
  for(let i=0;i<wmBand.length;i++) wmBand[i] *= gain;

  const out=new Float32Array(srcPCM.length);
  for(let i=0;i<out.length;i++) out[i]=srcPCM[i] + wmBand[i];

  // normalize softly
  let peak=0; for(let i=0;i<out.length;i++){ const a=Math.abs(out[i]); if(a>peak) peak=a; }
  if(peak>0.99){ const g=0.99/peak; for(let i=0;i<out.length;i++) out[i]*=g; }

  outPCM = out;
  const wav2 = encodeWav(outPCM, sampleRate);
  let u2 = null;
  try{
    if(window.makeSafeObjectURL){ u2 = window.makeSafeObjectURL(wav2); }
    else { u2 = URL.createObjectURL(wav2); }
  }catch(e){ u2 = null; }

  const finalize = (url)=>{
    try{ els.playerOut.src = url; }catch(e){}
    const a = document.createElement('a');
    a.href = url;
    a.download = 'spectroghost_stego_strict.wav';
    a.click();
  };
  if(u2 && typeof u2.then === 'function'){ u2.then(finalize).catch(()=>{}); }
  else if(u2){ finalize(u2); }

  await renderSpec(els.specB, outPCM, sampleRate, N, hop/N, 0, sampleRate/2);


}
/* ===== UI ===== */
document.getElementById('btnPreview').addEventListener('click', async ()=>{
  els.status.textContent='Rendering spectrogramsâ€¦';
  await renderSpec(els.specA, srcPCM, sampleRate, Number(els.fftSize.value), Number(els.hopPct.value)/100, 0, sampleRate/2);
  if(outPCM){ await renderSpec(els.specB, outPCM, sampleRate, Number(els.fftSize.value), Number(els.hopPct.value)/100, 0, sampleRate/2); }
  els.status.textContent='Done';
});
document.getElementById('btnEmbed').addEventListener('click', async ()=>{
  els.status.textContent='Embedding imageâ€¦';
  await embedAndRender();
  els.status.textContent='Done. Preview or re-embed if needed.';
});
</script>

</body></html>
